package v1alpha3

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	google_protobuf3 "github.com/gogo/protobuf/types"
)

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// EnvoyFilter is a Istio EnvoyFilter resource
type EnvoyFilter struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec EnvoyFilterSpec `json:"spec"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// EnvoyFilterList is a list of EnvoyFilter resources
type EnvoyFilterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata"`

	Items []EnvoyFilter `json:"items"`
}

type EnvoyFilter_ListenerMatch_ListenerType int32

type EnvoyFilter_ListenerMatch_ListenerProtocol int32

// Index/position in the filter chain.
type EnvoyFilter_InsertPosition_Index int32

type EnvoyFilter_Filter_FilterType int32

// `EnvoyFilter` describes Envoy proxy-specific filters that can be used to
// customize the Envoy proxy configuration generated by Istio networking
// subsystem (Pilot). This feature must be used with care, as incorrect
// configurations could potentially destabilize the entire mesh.
//
// NOTE 1: Since this is break glass configuration, there will not be any
// backward compatibility across different Istio releases. In other words,
// this configuration is subject to change based on internal implementation
// of Istio networking subsystem.
//
// NOTE 2: When multiple EnvoyFilters are bound to the same workload, all filter
// configurations will be processed sequentially in order of creation time.
// The behavior is undefined if multiple EnvoyFilter configurations conflict
// with each other.
//
// The following example for Kubernetes enables Envoy's Lua filter for all
// inbound calls arriving at service port 8080 of the reviews service pod with
// labels "app: reviews".
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: reviews-lua
// spec:
//   workloadLabels:
//     app: reviews
//   filters:
//   - listenerMatch:
//       portNumber: 8080
//       listenerType: SIDECAR_INBOUND #will match with the inbound listener for reviews:8080
//     filterName: envoy.lua
//     filterType: HTTP
//     filterConfig:
//       inlineCode: |
//         ... lua code ...
// ```
type EnvoyFilterSpec struct {
	// One or more labels that indicate a specific set of pods/VMs whose
	// proxies should be configured to use these additional filters.  The
	// scope of label search is platform dependent. On Kubernetes, for
	// example, the scope includes pods running in all reachable
	// namespaces. Omitting the selector applies the filter to all proxies in
	// the mesh.
	// NOTE: There can be only one EnvoyFilter bound to a specific workload.
	// The behavior is undefined if multiple EnvoyFilter configurations are
	// specified for the same workload.
	WorkloadLabels map[string]string `protobuf:"bytes,1,rep,name=workload_labels,json=workloadLabels" json:"workload_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// REQUIRED: Envoy network filters/http filters to be added to matching
	// listeners.  When adding network filters to http connections, care
	// should be taken to ensure that the filter is added before
	// envoy.http_connection_manager.
	Filters []*EnvoyFilter_Filter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
}

// Select a listener to add the filter to based on the match conditions.
// All conditions specified in the ListenerMatch must be met for the filter
// to be applied to a listener.
type EnvoyFilter_ListenerMatch struct {
	// The service port/gateway port to which traffic is being
	// sent/received. If not specified, matches all listeners. Even though
	// inbound listeners are generated for the instance/pod ports, only
	// service ports should be used to match listeners.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// Instead of using specific port numbers, a set of ports matching a
	// given port name prefix can be selected. E.g., "mongo" selects ports
	// named mongo-port, mongo, mongoDB, MONGO, etc. Matching is case
	// insensitive.
	PortNamePrefix string `protobuf:"bytes,2,opt,name=port_name_prefix,json=portNamePrefix,proto3" json:"port_name_prefix,omitempty"`
	// Inbound vs outbound sidecar listener or gateway listener. If not specified,
	// matches all listeners.
	ListenerType EnvoyFilter_ListenerMatch_ListenerType `protobuf:"varint,3,opt,name=listener_type,json=listenerType,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_ListenerMatch_ListenerType" json:"listener_type,omitempty"`
	// Selects a class of listeners for the same protocol. If not
	// specified, applies to listeners on all protocols. Use the protocol
	// selection to select all HTTP listeners (includes HTTP2/gRPC/HTTPS
	// where Envoy terminates TLS) or all TCP listeners (includes HTTPS
	// passthrough using SNI).
	ListenerProtocol EnvoyFilter_ListenerMatch_ListenerProtocol `protobuf:"varint,4,opt,name=listener_protocol,json=listenerProtocol,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_ListenerMatch_ListenerProtocol" json:"listener_protocol,omitempty"`
	// One or more IP addresses to which the listener is bound. If
	// specified, should match at least one address in the list.
	Address []string `protobuf:"bytes,5,rep,name=address" json:"address,omitempty"`
}

// Indicates the relative index in the filter chain where the filter should be inserted.
type EnvoyFilter_InsertPosition struct {
	// Position of this filter in the filter chain.
	Index EnvoyFilter_InsertPosition_Index `protobuf:"varint,1,opt,name=index,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_InsertPosition_Index" json:"index,omitempty"`
	// If BEFORE or AFTER position is specified, specify the name of the
	// filter relative to which this filter should be inserted.
	RelativeTo string `protobuf:"bytes,2,opt,name=relative_to,json=relativeTo,proto3" json:"relative_to,omitempty"`
}

// Envoy filters to be added to a network or http filter chain.
type EnvoyFilter_Filter struct {
	// Filter will be added to the listener only if the match conditions are true.
	// If not specified, the filters will be applied to all listeners.
	ListenerMatch *EnvoyFilter_ListenerMatch `protobuf:"bytes,1,opt,name=listener_match,json=listenerMatch" json:"listener_match,omitempty"`
	// Insert position in the filter chain. Defaults to FIRST
	InsertPosition *EnvoyFilter_InsertPosition `protobuf:"bytes,2,opt,name=insert_position,json=insertPosition" json:"insert_position,omitempty"`
	// REQUIRED: The type of filter to instantiate.
	FilterType EnvoyFilter_Filter_FilterType `protobuf:"varint,3,opt,name=filter_type,json=filterType,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_Filter_FilterType" json:"filter_type,omitempty"`
	// REQUIRED: The name of the filter to instantiate. The name must match a supported
	// filter _compiled into_ Envoy.
	FilterName string `protobuf:"bytes,4,opt,name=filter_name,json=filterName,proto3" json:"filter_name,omitempty"`
	// REQUIRED: Filter specific configuration which depends on the filter being
	// instantiated.
	FilterConfig *GoogleProtobuf3Struct `protobuf:"bytes,5,opt,name=filter_config,json=filterConfig" json:"filter_config,omitempty"`
}

// GoogleProtobuf3Struct - override to do the right DeepCopyInto
type GoogleProtobuf3Struct struct {
	google_protobuf3.Struct
}
func (m *GoogleProtobuf3Struct) Marshal() (dAtA []byte, err error) {
	return m.Marshal()
}
func (m *GoogleProtobuf3Struct) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalTo(dAtA)
}
func (m *GoogleProtobuf3Struct) Unmarshal(dAtA []byte) error {
	return m.Unmarshal(dAtA)
}
func (in *GoogleProtobuf3Struct) DeepCopyInto(out *GoogleProtobuf3Struct) {
	if out != nil {
		byt, err := in.Marshal()
		if err == nil && len(byt) > 0 {
			out.Unmarshal(byt)
		}
	}
}
